# Іспит (90 хв): Міні‑проєкт у Jupyter Notebook

- **Курс**: "Основи генеративного ШІ" (Комп'ютерна інженерія, 2 курс)
- **База курсу**: additional-course-materials/methodological-recommendations (ПР2–ПР7)
- **Формат**: 1 Jupyter Notebook, самостійне виконання в аудиторії
- **Час**: 90 хв

---

## Мета іспиту
- **Перевірити** вміння застосовувати техніки промпт‑інженерії (ПР2, ПР4).
- **Показати** базову роботу з GitHub Models/Azure AI Inference (ПР3, ПР4).
- **Уміти** керувати параметрами генерації та фіксувати результати (температура, токени).
- **Виконати** невелике індивідуальне завдання (варіант) із контролем формату/якості відповіді.

---

## Інструменти і моделі (обов’язково такі самі, як у практичних)
- **SDK/клієнти**: використовуйте ті самі приклади, що у ПР3/ПР4/ПР6/ПР7 (наприклад `azure-ai-inference` і `ChatCompletionsClient`).
- **Моделі**: ті, що використовувались у практичних через GitHub Models/Azure AI Inference (наприклад `gpt-4o-mini`, `phi-4`, `mistral` тощо — залежно від доступності у вашому середовищі).
- **Токени/ключі**: зчитування через `.env` (аналогічно до ПР1–ПР3). Заборонено хардкодити ключі у ноутбуці.

---

## Що потрібно здати
- **Файл**: один `.ipynb` з назвою `Прізвище І_Б_varNN.ipynb` (наприклад: `Петренко І.О._var07.ipynb`).
- **Завантаження**: на Google‑диск, вказаний викладачем (посилання буде повідомлене на іспиті).
- **Захист**: коротка усна демонстрація (3–5 хв) після завантаження.

---

## Структура ноутбука (рекомендований шаблон)
- **[0] Титул і варіант**
  - ПІБ, група, номер варіанту, обрана модель, endpoint.
- **[1] Підготовка середовища**
  - Імпорти; зчитування `GITHUB_TOKEN` з `.env`; швидкий тест виклику API (1 запит).
- **[2] Базова генерація (10–15 хв)**
  - Базовий промпт під вашу тему. 3 запусків із різними `temperature`/`max_tokens`.
  - Фіксуйте час/токени/якість (короткі нотатки).
- **[2b] Діалоговий режим чат-бота (5–10 хв)**
  - Реалізуйте простий чат у діалоговому режимі з історією повідомлень (`messages`).
  - Використовуйте той самий клієнт/endpoint, що в практичних (GitHub Models/Azure AI Inference, `ChatCompletionsClient` або `requests`).
  - Команди: `/exit` — завершення; `/reset` — очистити історію.
  - Параметри за замовчуванням: `temperature≈0.3`, `max_tokens≈300`. Дозволено змінити.
- **[3] Покращення промпту (15–20 хв)**
  - Додайте 1–2 прийоми з практичних: системний контекст, few‑shot, формат‑контракт (JSON), короткі правила безпеки, post‑перевірка.
  - Повторіть 1–2 запуски; коротко порівняйте з п.2.
- **[4] Індивідуальна частина (15–20 хв)**
  - Виконайте специфічне завдання згідно з вашим варіантом (див. таблицю варіантів).
- **[5] Рефлексія (5 хв)**
  - 5–7 речень: що спрацювало, що ні; які параметри/прийоми дали найбільший ефект; обмеження.

---

## Вимоги до академічної доброчесності
- Використовуйте **ті самі інструменти/моделі**, що у практичних (жодних зовнішніх чат‑ботів). 
- Виведіть у ноутбуці: `os.getenv("GITHUB_TOKEN") is not None`, свій GitHub username та відбиток часу першого запуску.
- Усі промпти/налаштування — власні під час іспиту.

---

## Оцінювання (100 б)

### Детальні критерії:

**[1] Підготовка середовища (10 б)**
- Токен завантажено та перевірено (3 б)
- Клієнт ініціалізовано (azure-ai-inference/requests) (3 б)
- Функція `ask_llm` реалізовано коректно (3 б)
- Sanity-check пройдено (1 б)

**[2] Базова генерація (25 б)**
- Мінімум 3 запити з різними параметрами (10 б)
- Результати зафіксовано у `results_base` (5 б)
- Висновки про вплив параметрів на якість (5 б)
- Аналіз latency/usage (5 б)

**[2b] Діалоговий режим (10 б)**
- Історія повідомлень реалізована (3 б)
- Команди `/exit`, `/reset` працюють (3 б)
- Безпечний цикл з обмеженням ходів (2 б)
- Демонстрація діалогу в виводі (2 б)

**[3] Покращення промпту (30 б)**
- Детальний системний контекст (8 б)
- Few-shot приклади (7 б)
- Формат-контракт (JSON) (7 б)
- Порівняння з базовою генерацією (5 б)
- 2-3 запуски для стабільності (3 б)

**[4] Індивідуальна частина (25 б)**
- 3+ приклади згенеровано (5 б)
- Валідація формату (JSON schema) (5 б)
- Порівняння результатів (таблиця/візуалізація) (5 б)
- Детальні висновки (5 б)
- Коректність даних перевірено (5 б)

**[5] Рефлексія (10 б)**
- Аналіз успішних технік (3 б)
- Опис проблем та обмежень (3 б)
- Висновки про найефективніші прийоми (2 б)
- Загальна оцінка виконання (2 б)

### Приклад успішного виконання (Варіант 30 - 87/100 б):

**Сильні сторони:**
- ✅ Середовище налаштовано коректно
- ✅ Діалоговий режим повністю функціональний
- ✅ Системний контекст та JSON-контракт застосовано
- ✅ 3 приклади оцінки згенеровано
- ✅ Рефлексія глибока та вичерпна

**Типові помилки для виправлення:**
- ❌ Відсутні висновки про вплив параметрів (Секція [2])
- ❌ Один тестовий запуск замість 2-3 (Секція [3])
- ❌ Валідація лише через try/except, не jsonschema (Секція [4])
- ❌ Відсутня порівняльна таблиця результатів (Секція [4])

**Рекомендовані покращення:**
- Додати `jsonschema` для валідації
- Створити pandas DataFrame для порівняння
- Зробити 2-3 запити в кожній секції
- Писати текстові висновки після кожної секції

Ключове: коректні виклики API, відтворюваність, короткі висновки, дотримання формату.

---

## Підказки до інструментів (узгоджено з практичними)
- **ПР2**: системний контекст, few‑shot, аналіз токенізації (за бажанням — коротко).
- **ПР3/ПР4**: `ChatCompletionsClient`, параметри `temperature`, `max_tokens`, ролі.
- **ПР6**: формат JSON Schema/контракт, контроль структури відповіді.
- **ПР5/ПР7**: мінімальний контекст або мікро‑RAG (1–2 фрагменти) — лише якщо це прямо потрібно у варіанті.

---

## 30 індивідуальних варіантів
Виконуйте у секції [4]. Оберіть завдання за номером вашого варіанту.

**Стандартна структура кожного варіанту**: генеруйте 3+ приклади → валідуйте формат → порівняйте результати → зробіть висновки.

1. **Алгоритми сортування**: Генерувати 3 реалізації (bubble, quick, merge) у JSON `{name, code[], complexity, pros, cons}`. Порівняти продуктивність, валідувати синтаксис.
2. **Структури даних**: Створити JSON-опис 3 структур (array, linked list, tree) `{type, operations[], memory_usage, use_cases}`. Валідувати схему, порівняти ефективність.
3. **Криптографія**: Генерувати 3 методи шифрування (AES, RSA, SHA) у JSON `{algorithm, key_length, speed, security_level}`. Порівняти безпеку та продуктивність.
4. **Мережеві протоколи**: Описати 3 протоколи (TCP, UDP, HTTP) у JSON `{name, layer, reliability, use_case}`. Валідувати поля, порівняти характеристики.
5. **Бази даних**: Створити JSON для 3 типів БД (SQL, NoSQL, Graph) `{type, query_language, scalability, examples}`. Порівняти для різних сценаріїв.
6. **Операційні системи**: Генерувати 3 ОС (Linux, Windows, RTOS) у JSON `{name, kernel_type, real_time, use_cases}`. Валідувати, порівняти для embedded.
7. **Компілятори**: Описати 3 компілятори (GCC, Clang, MSVC) у JSON `{name, language, optimization, target}`. Порівняти продуктивність коду.
8. **Веб-фреймворки**: Створити JSON для 3 фреймворків (React, Angular, Vue) `{name, language, performance, learning_curve}`. Валідувати, порівняти для проектів.
9. **Мобільні платформи**: Генерувати 3 платформи (iOS, Android, Flutter) у JSON `{platform, language, deployment, market_share}`. Порівняти для розробки.
10. **Хмарні сервіси**: Описати 3 хмарні платформи (AWS, Azure, GCP) у JSON `{provider, services, pricing, reliability}`. Валідувати, порівняти вартість.
11. **Контейнери**: Створити JSON для 3 технологій (Docker, Podman, LXC) `{name, isolation, performance, use_cases}`. Порівняти для мікросервісів.
12. **Мікросервіси**: Генерувати 3 архітектурні підходи у JSON `{pattern, complexity, scalability, examples}`. Валідувати, порівняти з monolith.
13. **API дизайн**: Описати 3 стилі API (REST, GraphQL, gRPC) у JSON `{style, format, performance, tools}`. Порівняти для різних клієнтів.
14. **Тестування**: Створити JSON для 3 типів тестів (unit, integration, E2E) `{type, scope, tools, automation}`. Валідувати, порівняти покриття.
15. **CI/CD пайплайни**: Генерувати 3 підходи (Jenkins, GitHub Actions, GitLab CI) у JSON `{tool, config, speed, integration}`. Порівняти для проектів.
16. **Моніторинг**: Описати 3 системи моніторингу (Prometheus, Grafana, ELK) у JSON `{tool, metrics, visualization, alerting}`. Валідувати, порівняти функціональність.
17. **Безпека**: Створити JSON для 3 методів автентифікації (JWT, OAuth, SAML) `{method, security, complexity, use_cases}`. Порівняти для веб-додатків.
18. **Перформанс**: Генерувати 3 техніки оптимізації у JSON `{technique, impact, implementation, risks}`. Валідувати, порівняти ефективність.
19. **Машинне навчання**: Описати 3 алгоритми (linear regression, decision tree, neural net) у JSON `{algorithm, data_needed, accuracy, speed}`. Порівняти для задач.
20. **Deep Learning**: Створити JSON для 3 архітектур (CNN, RNN, Transformer) `{type, input_data, use_cases, complexity}`. Валідувати, порівняти продуктивність.
21. **Комп'ютерний зір**: Генерувати 3 техніки (classification, detection, segmentation) у JSON `{technique, output, accuracy, compute}`. Порівняти для застосувань.
22. **NLP моделі**: Описати 3 підходи (BERT, GPT, T5) у JSON `{model, task, size, performance}`. Валідувати, порівняти для тексту.
23. **Embedded системи**: Створити JSON для 3 мікроконтролерів (Arduino, ESP32, STM32) `{mcu, memory, peripherals, cost}`. Порівняти для IoT.
24. **FPGA програмування**: Генерувати 3 мови (VHDL, Verilog, Chisel) у JSON `{language, abstraction, synthesis, ecosystem}`. Валідувати, порівняти для проектів.
25. **Real-time системи**: Описати 3 RTOS (FreeRTOS, Zephyr, QNX) у JSON `{rtos, scheduler, footprint, certification}`. Порівняти для critical systems.
26. **IoT протоколи**: Створити JSON для 3 протоколів (MQTT, CoAP, LoRaWAN) `{protocol, bandwidth, range, power}`. Валідувати, порівняти для сенсорів.
27. **Бездротові мережі**: Генерувати 3 стандарти (WiFi, Bluetooth, Zigbee) у JSON `{standard, speed, range, power}`. Порівняти для пристроїв.
28. **Системи зберігання**: Описати 3 типи (SSD, HDD, NVMe) у JSON `{type, speed, durability, cost}`. Валідувати, порівняти для даних.
29. **Віртуалізація**: Створити JSON для 3 технологій (VM, containers, serverless) `{tech, isolation, overhead, scaling}`. Порівняти для деплойменту.
30. **DevOps практики**: Генерувати 3 практики (IaC, GitOps, Blue-Green) у JSON `{practice, tools, benefits, challenges}`. Валідувати, порівняти для команд.

---

## Таймінг (орієнтир)
- [1] 5–10 хв
- [2] 15–20 хв
- [2b] 10–15 хв
- [3] 20–25 хв
- [4] 25–30 хв
- [5] 5–10 хв

---

## Нотатки щодо середовища
- За потреби використовуйте готові приклади з ноутбуків розділів 06/07/11 (виклик через `ChatCompletionsClient`).
- Усі ключі — лише через `.env`. Не друкуйте значення ключів у вивід.
- За відсутності мережі продемонструйте сформовані промпти, параметри та очікувані формати відповідей.
